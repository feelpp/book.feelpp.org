= Manipulate Expressions
include::user:ROOT:partial$header-macros.adoc[]
:page-jupyter: true

We start with setting the {feelpp} environment and loading the {feelpp} library.

.Set the {feelpp} environment with local repository
[source,python]
----
import feelpp 
import sys
app = feelpp.Environment(["myapp"],config=feelpp.localRepository(""))
----

== Create and evaluate expressions

An expression is a mathematical expression that can be evaluated at a given point and depend on multiple variables. 
It can be a scalar, a vectorial or a matricial expression. 
The expression can be created from a string.
The expression can be then evaluated at a given point.

=== Scalar expression

.Create a scalar expression abd evaluate the expression at a given point (1,2)
[source,python]
----
expr = feelpp.expr("x+y:x:y") # <1>
expr.evaluate({"x":1,"y":2}) # <2>
----
<1> Create a scalar expression from a string, the symbols are listed at the end of the string using `:` as separator.
<2> Evaluate the expression at the point (1,2), it returns a array with one element.

[%collapsible.result]
.Results
====
----
array([3.])
----
====

The expression can also be evaluated at a set of points.

.Evaluate the expression at a set of points
[source,python]
----
expr.setParameterValues({"y":2}) # <1>
import numpy as np
x=np.linspace(0,1,10) # <2>
expr.evaluate("x",x) # <3>
----
<1> Set the value of the parameter `y` to 2
<2> Create a numpy array with 10 points between 0 and 1
<3> Evaluate the expression at the 10 equidistributed points between 0 and 1, it returns a array with two elements.


[%collapsible.result]
.Results
====
----
array([2.        , 2.11111111, 2.22222222, 2.33333333, 2.44444444,
       2.55555556, 2.66666667, 2.77777778, 2.88888889, 3.        ])
----
====

=== Vectorial expression

.Create a vectorial expression abd evaluate the expression at a given point (1,2)
[source,python]
----
expr = feelpp.expr("x+y:x:y") # <1>
expr.evaluate({"x":1,"y":2}) # <2>
----
<1> Create a vectorial expression from a string, the symbols are listed at the end of the string using `:` as separator.
<2> Evaluate the expression at the point (1,2), it returns a array with two elements.

[%collapsible.result]   
.Results
====
----
array([1., 3.])
----
====

=== Matricial expression

.Create a matricial expression abd evaluate the expression at a given point (1,2)
[source,python]
----
expr = feelpp.expr("x+y:x:y") # <1>
expr.evaluate({"x":1,"y":2}) # <2>
----
<1> Create a matricial expression from a string, the symbols are listed at the end of the string using `:` as separator.
<2> Evaluate the expression at the point (1,2), it returns a array with four elements.

[%collapsible.result]
.Results
====
----
array([[1., 3.],
       [3., 5.]])
----
====

== Differentiation

The member functions `diff` and `diff2` allows to compute the first and second symbolic derivatives of a function. The first argument is the symbol with respect to which the derivative is computed. 
[source,python]
----
ex=feelpp.expr("a*sin(x):x:a")
ex.setParameterValues({"a":1})
exd = ex.diff("x") # <1>
exd2 = ex.diff2("x") # <2>
exda = ex.diff("a") # <3>
exdax = ex.diff("a").diff("x") # <4>
x=np.linspace(0,2*math.pi,200)
print(f"   ex: {ex}")
print(f"  exd: {exd}")
print(f" exd2: {exd2}")
print(f" exda: {exda}")
print(f"exdaa: {exdax}")
----
<1> First derivative with respect to `x`stem:[\frac{\partial \cdot }{\partial x}] 
<2> Second derivative with respect to `x`stem:[\frac{\partial^2 \cdot }{\partial^2 x}] 
<3> First derivative with respect to `a` stem:[\frac{\partial \cdot }{\partial a}]
<4> First derivative with respect to `a` and then with respect to `x` stem:[\frac{\partial^2 \cdot}{\partial x \partial a}]


[%collapsible.result]
.Results
====
----
   ex: sin(x)*a
  exd: a*cos(x)
 exd2: -sin(x)*a
 exda: sin(x)
exdax: cos(x)
----
====

Now let's plot the expression and its derivative.
The first and last are the same.

[source,python]
----
import plotly.graph_objects as go
fig = go.Figure()
fig.add_trace(go.Scatter(x=x, y=ex.evaluate("x",x), name="sin(x)"))
fig.add_trace(go.Scatter(x=x, y=exd.evaluate("x",x), name="cos(x)"))
fig.add_trace(go.Scatter(x=x, y=exd2.evaluate("x",x), name="-sin(x)"))
fig.add_trace(go.Scatter(x=x, y=exda.evaluate("x",x), name="sin(x)"))
fig.show()
----

[%collapsible.result]
.Results
====
image::pyfeelpp/plot-expr-diff.png[]
====

== Next steps

- [x] xref:pyfeelpp/discr.adoc[Manipulate function and function spaces]
- [x] xref:pyfeelpp/integrals.adoc[Compute integrals]