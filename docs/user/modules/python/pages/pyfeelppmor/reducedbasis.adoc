= Reduced basis, pyfeelpp

== Module `reducedbasis`

:stem: latexmath

=== Import

NOTE: The work has not yet been merged in `develop`. To include the module at current state, you need to checkout the branch https://github.com/feelpp/feelpp/tree/feature/pyrb[`feature/pyrb`], and move to the directory https://github.com/feelpp/feelpp/tree/feature/pyrb/mor/pyfeelpp-mor/feelpp/mor[mor/pyfeelpp-mor/feelpp/mor].

Line to import the module :

[source, python]
----
from feelpp.mor.reducedbasis.reducedbasis import *
----

To set the environment, those module also need to be imported :

[source, python]
----
import sys
from feelpp.toolboxes.heat import *
from feelpp.toolboxes.core import *
from feelpp.mor import *
import feelpp
----


=== Set the model

To declare the objects, use these lines :

[source,python]
----
DIM = 2
heatBox=heat(dim=DIM,order=1)
heatBox.init()
model = toolboxmor(dim=DIM, time_dependent=False)
model.setFunctionSpaces( Vh=heatBox.spaceTemperature())
----

- `DIM` is the dimension of the case (should be `2` or `3`)
- `time_dependent` depends if the case is time-steady or time-dependant.

Those functions define how the `DEIM` matrix and right-hand side are updated according to the parameter `mu`.
[source,python]
----
def assembleDEIM(mu):
    for i in range(0,mu.size()):
        heatBox.addParameterInModelProperties(mu.parameterName(i),mu(i))
    heatBox.updateParameterValues()
    return heatBox.assembleRhs()

def assembleMDEIM(mu):
    for i in range(0,mu.size()):
        heatBox.addParameterInModelProperties(mu.parameterName(i),mu(i))
    heatBox.updateParameterValues()
    return heatBox.assembleMatrix()

model.setAssembleDEIM(fct=assembleDEIM)
model.setAssembleMDEIM(fct=assembleMDEIM)
model.initModel()
----

WARNING: When the function `assembleDEIM` is called, the value of the parameters of the object `heatBox` is updated.

Creation of `DEIM` and `MDEIM` toolboxes, with the associated assembly functions.


[source,python]
----
heatBoxDEIM=heat(dim=DIM,order=1)
meshDEIM = model.getDEIMReducedMesh()
heatBoxDEIM.setMesh(meshDEIM)
heatBoxDEIM.init()

def assembleOnlineDEIM(mu):
    for i in range(0,mu.size()):
        heatBoxDEIM.addParameterInModelProperties(mu.parameterName(i),mu(i))
    heatBoxDEIM.updateParameterValues()
    return heatBoxDEIM.assembleRhs()

model.setOnlineAssembleDEIM(assembleOnlineDEIM)

heatBoxMDEIM=heat(dim=DIM,order=1)
meshMDEIM = model.getMDEIMReducedMesh()
heatBoxMDEIM.setMesh(meshMDEIM)
heatBoxMDEIM.init()

def assembleOnlineMDEIM(mu):
    for i in range(0,mu.size()):
        heatBoxMDEIM.addParameterInModelProperties(mu.parameterName(i),mu(i))
    heatBoxMDEIM.updateParameterValues()
    return heatBoxMDEIM.assembleMatrix()

model.setOnlineAssembleMDEIM(assembleOnlineMDEIM)
----

Then finalize the initialization :

[soucre,python]
----
model.postInitModel()
model.setInitialized(True)
----


=== Access to a parameter

[source,python]
----
Dmu = model.parameterSpace()
mu = Dmu.element(True, False)
----

See xref:pyfeelppmor/parameters.adoc[the dedicated page] for the API of `ParameterSpaceElement`.





= Usage of Feelpp / Mor

== Offline part

=== Usage

This part can be run in parallel.

.Usage of `generate_basis` script
[source, bash]
----
[mpirun -np <nproc>] python3 generate_basis.py
    --config-file <path to cfg file>
    --odir <path to export directory>
    --dim <DIM>
    [--algo {0|1|2}]
    [--train-size <size>]
    [--tol <tol>]
    [--time-dependant={True | False}]
----

[cols="1,1,1"]
|===
|Name|Description|Default value

|`config-file`
|path to config `cfg` file
|_mandatory_

|`odir`
|path to output directory, where data will be saved
|_mandatory_

|`dim`
|dimension of the case (must be `2` or `3`)
|_mandatory_

|`algo`
|algorithm used to generate a basis, see <<Algorithms, table below>>
|`1`

|`train-size`
|Size of the train set (depending on algorithm used)
|`40`

|`tol`
|tolerance used for generating (depends on algorithm)
|`1e-6`

|`time-dependant`
|time dependant case
|`False`
|===

WARNING: The time-dependant case it net yet functionnal...


[[Algorithms]]
=== Algorithms


[cols='1,2,5']
|===
|Value|Algorithm|Description

|0
|From sample
|Generates a basis of size stem:[N=]`train-size` elements, [log-]randomly taken in the space.

|1
|Greedy algorithm
|Run the greedy algorithm on a train set of element of size `train-size`. This algorithm also stores the evolution of the maximal error bound at each step.

|2
|POD generation
|Takes the largest POD modes from a basis of size `train-size`. The resulting basis will have a size stem:[N\leqslant]`train-size`. This algorithm also stores the evolution of the maximal error bound at each step.

|===

WARNING: For now, the computation of error bound is only valid when the decomposition is coercive (_i.e._ stem:[A(\mu)=\displaystyle\sum_{q}\beta_A(\mu)A^q], with stem:[\beta_A(\mu)\geqslant 0])

[[offline]]
=== Exported files

Here is a description of the generated files :

1. A `JSON` file, exported in `odir` directory, containing the following informations :
    - `Qa` : Size of the decomposition of stem:[A(\mu)]
    - `Qf` : Size of the decomposition of stem:[F(\mu)]
    - `N` : Size of the reduced basis
    - `path` : Path where `h5` file is stored 
    - `mubar` : Values of stem:[\bar{\mu}]

2. A `h5` file, containing all the matrices used in the online part (of « small » size).

== Online part

=== Load the generated basis

The following pieces of code can be unsed in a sequential script, or even in a notebook for vizualisation.

.Load the packages
[source, python]
----
import sys, os
import numpy as np
import feelpp
import feelpp.mor.reducedbasis.reducedbasis as rb
from feelpp.toolboxes.heat import *
from feelpp.toolboxes.core import *
from feelpp.mor import *
----

.Set the environment
[source, python]
----
config_file = "path" <1>
odir = "path"<2>
dim = 2 <3>
config = feelpp.globalRepository(f'{odir}')
sys.argv = ['generate-basis']
o = toolboxes_options("heat")
o.add(makeToolboxMorOptions())

e = feelpp.Environment(sys.argv, opts=o, config=config)
----

<1> Path to the cfg file used to generate the basis
<2> Path to the directory where the offline basis is stored
<3> Dimension of the case (`2` or `3`)

.Set the toolboxmor model, necessary to run online computation
[source, python]
----
feelpp.Environment.setConfigFile(casefile)
feelpp.Environment.changeRepository(directory=odir)

heatBox = heat(dim=dim, order=1)
heatBox.init()

model = toolboxmor(dim=dim, time_dependent=time_dependant)
model.setFunctionSpaces( Vh=heatBox.spaceTemperature() )

def assembleDEIM(mu):
    for i in range(0,mu.size()):
        heatBox.addParameterInModelProperties(mu.parameterName(i), mu(i))
    heatBox.updateParameterValues()
    return heatBox.assembleRhs()

def assembleMDEIM(mu):
    for i in range(0,mu.size()):
        heatBox.addParameterInModelProperties(mu.parameterName(i), mu(i))
    heatBox.updateParameterValues()
    return heatBox.assembleMatrix()

model.setAssembleDEIM(fct=assembleDEIM)
model.setAssembleMDEIM(fct=assembleMDEIM)

model.initModel()

heatBoxDEIM = heat(dim=dim, order=1)
meshDEIM = model.getDEIMReducedMesh()
heatBoxDEIM.setMesh(meshDEIM)
heatBoxDEIM.init()

heatBoxMDEIM = heat(dim=dim, order=1)
meshMDEIM = model.getMDEIMReducedMesh()
heatBoxMDEIM.setMesh(meshMDEIM)
heatBoxMDEIM.init()

def assembleOnlineDEIM(mu):
    for i in range(0,mu.size()):
        heatBoxDEIM.addParameterInModelProperties(mu.parameterName(i),mu(i))
    heatBoxDEIM.updateParameterValues()
    return heatBoxDEIM.assembleRhs()

def assembleOnlineMDEIM(mu):
    for i in range(0,mu.size()):
        heatBoxMDEIM.addParameterInModelProperties(mu.parameterName(i),mu(i))
    heatBoxMDEIM.updateParameterValues()
    return heatBoxMDEIM.assembleMatrix()

model.setOnlineAssembleDEIM(assembleOnlineDEIM)
model.setOnlineAssembleMDEIM(assembleOnlineMDEIM)

model.postInitModel()
model.setInitialized(True)
----

.Load the generated basis
[source, python]
----
basis = rb.reducedbasis(None)
basis.loadReducedBasis('<path-to-json-file>/reducedbasis.json', model) <1>
----

<1> Path to the json file, generated in the <<offline, offline stage>>.


=== Run online computations

The space of parameters can be retreived with this line

[source, python]
----
Dmu = model.parameterSpace()
----

The resulting object `Dmu` is a `parameterSpace`, see the dedicated xref:pyfeelppmor/parameterSpace.adoc[documentation page], and the one about xref:pyfeelppmor/parameters.adoc[parameters]


.Get offline solution
[source, python]
----
uN,sN = basisSample.getSolutions(mu)
----

NOTE: In the current state of the work, the output is defined as the right-hand side member in the variational formulation of the problem.