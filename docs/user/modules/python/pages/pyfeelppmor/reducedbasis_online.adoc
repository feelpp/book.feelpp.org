= Usage of Feelpp / Mor : Online part

:stem: latexmath

== Load the generated basis

The following pieces of code can be unsed in a sequential script, or even in a notebook for vizualisation.

NOTE: The following code is meant to be used for a basis created with the script xref:pyfeelppmor/reducedbasis_offline.adoc[`generete_basis.py`].

.Load the packages
[source, python]
----
import sys, os
import numpy as np
import feelpp
import feelpp.mor.reducedbasis.reducedbasis as rb
from feelpp.toolboxes.heat import *
from feelpp.toolboxes.core import *
from feelpp.mor import *
----

.Set the environment
[source, python]
----
config_file = "path" <1>
odir = "path" <2>
dim = 2 <3>
time_dependant = False

name = "name" <4>
NCORES = ncores  <5>


config = feelpp.globalRepository(f"generate_basis-{name}")
sys.argv = ['generate-basis']
o = toolboxes_options("heat")
o.add(makeToolboxMorOptions())

e = feelpp.Environment(sys.argv, opts=o, config=config)
----

<1> Path to the cfg file used to generate the basis
<2> Path to the directory where the offline basis is stored
<3> Dimension of the case (`2` or `3`)
<4> Name of the case used on the script generate_basis
<5> Number of cores used to generate the basis


To load the parameters used to generete the space, we have to ensure taht we are in the same directory as during the offline phasis. The corresponding directory should be like :
```
<feel-dir>/generated_basis-<name>/np_<NOCRES>/
```

To do so, we can use the following code :

[soucre, python]
----
cwd = os.getcwd()
os.chdir(cwd.replace('np_1', f'np_{NCORES}'))
----


.Set the toolboxmor model, necessary to run online computation
[source, python]
----
feelpp.Environment.setConfigFile(casefile)

heatBox = heat(dim=dim, order=1)
heatBox.init()

model = toolboxmor(name=name, dim=dim, time_dependent=time_dependant)
model.setFunctionSpaces( Vh=heatBox.spaceTemperature() )

def assembleDEIM(mu):
    for i in range(0,mu.size()):
        heatBox.addParameterInModelProperties(mu.parameterName(i), mu(i))
    heatBox.updateParameterValues()
    return heatBox.assembleRhs()

def assembleMDEIM(mu):
    for i in range(0,mu.size()):
        heatBox.addParameterInModelProperties(mu.parameterName(i), mu(i))
    heatBox.updateParameterValues()
    return heatBox.assembleMatrix()

model.setAssembleDEIM(fct=assembleDEIM)
model.setAssembleMDEIM(fct=assembleMDEIM)

model.initModel()
----

NOTE: During the initialisation of the toolboxmor `model`, directories paths are created. They sould be the same as the one described xref:reducedbasis_offline.adoc#files[here].


[source, python]
----
heatBoxDEIM = heat(dim=dim, order=1)
meshDEIM = model.getDEIMReducedMesh()
heatBoxDEIM.setMesh(meshDEIM)
heatBoxDEIM.init()

heatBoxMDEIM = heat(dim=dim, order=1)
meshMDEIM = model.getMDEIMReducedMesh()
heatBoxMDEIM.setMesh(meshMDEIM)
heatBoxMDEIM.init()

def assembleOnlineDEIM(mu):
    for i in range(0,mu.size()):
        heatBoxDEIM.addParameterInModelProperties(mu.parameterName(i),mu(i))
    heatBoxDEIM.updateParameterValues()
    return heatBoxDEIM.assembleRhs()

def assembleOnlineMDEIM(mu):
    for i in range(0,mu.size()):
        heatBoxMDEIM.addParameterInModelProperties(mu.parameterName(i),mu(i))
    heatBoxMDEIM.updateParameterValues()
    return heatBoxMDEIM.assembleMatrix()

model.setOnlineAssembleDEIM(assembleOnlineDEIM)
model.setOnlineAssembleMDEIM(assembleOnlineMDEIM)

model.postInitModel()
model.setInitialized(True)
----

.Load the generated basis
[source, python]
----
basis = rb.reducedbasis(None)
basis.loadReducedBasis('<path-to-json-file>/reducedbasis.json', model) <1>
----

<1> Path to the json file, generated in the xref:pyfeelppmor/reducedbasis_offline.adoc[offline stage].


== Run online computations

The space of parameters can be retreived with this line

[source, python]
----
Dmu = model.parameterSpace()
----

The resulting object `Dmu` is a `parameterSpace`, see the dedicated xref:pyfeelppmor/parameterSpace.adoc[documentation page], and the one about xref:pyfeelppmor/parameters.adoc[parameters]


.Get offline solution
[source, python]
----
uN,sN = basisSample.getSolutions(mu, k=k)
----

The integer `k` corresponds to the output desired in stem:[[|1, n_\text{outputs}|\]. If `-1` is given, then the compliant output is computed.
