:cfpdes: Coefficient Form PDEs 
= The Poisson equation with {cfpdes} toolbox
:feelpp: Feel++
:stem: latexmath
:page-jupyter: true

== Introduction

This page is devoted to the finite element approximation of coercive problems. 

The prototype is the Dirichlet problem: given a function stem:[f: \Omega \rightarrow \mathbb{R}],  look for a function stem:[u: \Omega \rightarrow \mathbb{R}] such that
[[laplace]]
[stem]
++++
\begin{equation*}
\begin{aligned}
-\Delta u & =f & & \text { in } \Omega, \\
u & =0 & & \text { on } \partial \Omega,
\end{aligned}
\end{equation*}
++++
where stem:[\Delta u=\sum_{i=1}^d \partial_{i i}^2 u] is the Laplacian of stem:[u]. 

Equation <<laplace>>, which imposes the nullity of the solution stem:[u] on the domain boundary, is called a homogeneous Dirichlet boundary condition.

Other boundary conditions (non-homogeneous Dirichlet, Neumann or Robin) are possible and will be discussed later on. 

The problem is used in many physical models, in particular 

- in heat transfer where stem:[u] represents the temperature,
- in electrostatics where stem:[u] represents an electric potential, 
- in mechanics where stem:[u] represents a vertical membrane displacement, and 
- in hydraulics where stem:[u] represents a charge in a Darcy flow. 

A second example of a coercive problem is the advection-diffusion-reaction equations with dominant diffusion which we shall study xref:pyfeelpptoolboxes/cfpdes.adr.adoc[here].

A third example is provided by the mechanics of continuous deformable media in the framework of linear elasticity which we shall study xref:pyfeelpptoolboxes/cfpdes.linearelasticity.adoc[here]. 
In this case, the unknown is a function stem:[u: \Omega \rightarrow \mathbb{R}^d] which represents a displacement field. 


NOTE: Coercive problems provided the first framework for the application of the finite element method, when engineers used this method in the 1950's to approximate the solution of deformable continuum mechanics problems. 

The mathematical analysis of coercivity problems is relatively simple since it is based on the Lax-Milgram lemma.

== The mathematical framework

We assume for simplicity that the data stem:[f] is in stem:[L^2(\Omega)]. 
The weak formulation of the  <<laplace,homogeneous Dirichlet problem>> is the following:
[[laplace-varf]]
[stem]
++++
\begin{equation*}
\left\{\begin{array}{l}
\text { Find } u \in H_0^1(\Omega) \text { such that } \\
\int_{\Omega} \nabla u \ \nabla w=\int_{\Omega} f w, \quad \forall w \in H_0^1(\Omega) .
\end{array}\right.
\end{equation*}
++++

Introducing the functional space stem:[V=H_0^1(\Omega)], the bilinear form stem:[a \in \mathcal{L}(V \times V; \mathbb{R})] defined by stem:[a(v, w)=\int_{\Omega} \nabla v \cdot \nabla w] and the linear form stem:[f \in V^{\prime}] defined by stem:[f(w)=\int_{\Omega} f w], the  <<laplace-varf,problem>> is written in the following abstract form:
[stem]
++++
\begin{equation*}
\left\{\begin{array}{l}
\text { Find } u \in V \text { such that } \\
a(u, w)=f(w), \quad \forall w \in V .
\end{array}\right.
\end{equation*}
++++


The space stem:[V] equipped with the norm stem:[\|\cdot\|_{1, \Omega}] (defined by stem:[\|v\|_{1, \Omega}=\left(\|v\|_{0, \Omega}^2+\|\nabla v\|_{0, \Omega}^2\right)^{1 / 2}] for stem:[v \in V] ) is a Hilbert space and the forms stem:[a] and stem:[f] are continuous on stem:[V \times V] and stem:[V], respectively. 
The only non-trivial property to establish the well-posedness of <<laplace-varf>> is the coercivity of stem:[a] on stem:[H_0^1(\Omega)]. 
This results from the following inequality 

[[lem:1]]
.Lemma: Poincaré inequality
****
Let stem:[\Omega] be a bounded open of stem:[\mathbb{R}^d]. 
There exists a constant stem:[\ell_{\Omega}] such that
[stem]
++++
\begin{equation*}
\forall v \in H_0^1(\Omega), \quad\|v\|_{0, \Omega} \leq \ell_{\Omega}||\nabla v\|_{0, \Omega}
\end{equation*}
++++
****

NOTE:  the constant stem:[\ell_{\Omega}] has the dimension of a length; it can be interpreted as a characteristic length of the bounded open stem:[\Omega].

The Poincaré inequality implies the coercivity of the bilinear form stem:[a] on stem:[H_0^1(\Omega)] since
[stem]
++++
\begin{equation*}
\forall v \in H_0^1(\Omega), \quad a(v, v)=\|\nabla v|_{0, \Omega}^2 \geq \frac{1}{1+\ell_{\Omega}^2}\|v\|_{1, \Omega}^2 .
\end{equation*}
++++

The Lax-Milgram lemma allows us to conclude that the <<laplace-varf,problem>> is well-posed.

=== Conforming Approximation 


We consider a conformal approximation of <<laplace-varf,problem>>  by Lagrange finite elements. 
We assume for simplicity that stem:[\Omega] is a stem:[\mathbb{R}^2] polygon or a stem:[\mathbb{R}^3] polyhedron. 
We consider a regular and conformal family of affine meshes of stem:[\Omega] which we denote stem:[\left\{\mathcal{T}_h\right\}_{h>0}]. 

We choose as finite element of reference stem:[\left\{\widehat{K}, \widehat{P}, \widehat{\Sigma}\right\}] a finite element of Lagrange such that stem:[\mathbb{P}_k \subset \widehat{P}] and stem:[k+1>\frac{d}{2}] 

We pose
[stem]
++++
\begin{equation*}
P_{\mathrm{c}, h}^k=\left\{v_h \in \mathcal{C}^0(\bar{\Omega}); \forall K \in \mathcal{T}_h, v_h \circ T_K \in \widehat{P}\right\}
\end{equation*}
++++
where stem:[T_K] is the geometric transformation sending stem:[\widehat{K}] into stem:[K]. 
The space stem:[P_{\mathrm{c}, h}^k] is the space of the functions of stem:[\mathcal{C}^0(\bar{\Omega})] which are continuous on the boundary of stem:[\Omega] and which are piecewise polynomials of degree stem:[k] on each element of stem:[\mathcal{T}_h].

In order to construct an approximation space which is included in stem:[V=H_0^1(\Omega)], we pose
[stem]
++++
\begin{equation*}
V_h=P_{\mathrm{c}, h}^k \cap H_0^1(\Omega)
\end{equation*}
++++

The elements of stem:[V_h] are the functions of stem:[P_{\mathrm{c}, h}^k] which are stem:[0] on the boundary of stem:[\Omega]. 


We consider the following approximate problem:
[stem]
++++
\begin{equation*}
\left\{\begin{array}{l}
\text { Find } u_h \in V_h \text { such that } \\
a\left(u_h, v_h\right)=f\left(v_h\right), \quad \forall v_h \in V_h,
\end{array}\right.
\end{equation*}
++++
which is clearly well-posed since stem:[a] is coercive on stem:[V] and stem:[V_h \subset V].

[[thm:1]]
.Convergence theorem of the conforming approximation 
****
With the above assumptions, we suppose that the unique solution stem:[u] of <<laplace-varf, the problem>> is in stem:[H^{k+1}(\Omega) \cap H_0^1(\Omega)]. 
Then there exists a constant stem:[c] such that for all stem:[h],
[[thm:1:1]]
[stem]
.stem:[H^1] estimate
++++
\begin{equation*}
\left\|u-u_h\right\|_{1, \Omega} \leq c h^k|u|_{k+1, \Omega}
\end{equation*}
++++

where stem:[|u|_{k+1, \Omega}=\left(\|u\|_{0, \Omega}^2+\|\nabla u\|_{0, \Omega}^2+\dots+\|\nabla^{k+1} u\|_{0, \Omega}^2\right)^{1 / 2}].
Moreover, if  <<laplace-varf, the problem>> is regularizing, there exists a constant stem:[c] such that for all stem:[h],

[[thm:1:2]]
[stem]
.stem:[L^2] estimate
++++
\begin{equation*}
\left\|u-u_h\right\|_{0, \Omega} \leq c h^{k+1}|u|_{k+1, \Omega}
\end{equation*}
++++

.Notes on the proof
[%collapsible]
====
The <<thm:1:1>> results from the lemma of Céa  and an interpolation theorem. 
Indeed, we have
[stem]
++++
\begin{equation*}
\begin{aligned}
\left\|u-u_h\right\|_{1, \Omega} & \leq c \inf _{v_h \in V_h}\left\|u-v_h\right\|_{1, \Omega} \\ 
& \leq c\left\|u-\mathcal{I}_h^{\mathrm{Lag}} u\right\|_{1, \Omega} \\ 
& \leq c h^k|u|_{k+1, \Omega}
\end{aligned}
\end{equation*}
++++
where stem:[\mathcal{I}_h^{\mathrm{Lag}}] is the Lagrangian interpolation operator. 

Moreover, the <<thm:1:2>> follows from the Aubin-Nitsche lemma which allows us to state that
[stem]
.Aubin-Nitsche lemma
++++
\begin{equation*}
\left\|u-u_h\right\|_{0, \Omega} \leq c h\left|u-u_h\right|_{1, \Omega}
\end{equation*}
++++
so that <<thm:1:2>> is deduced from <<thm:1:1>>.
====
****

[NOTE]
.Note on stem:[\mathbb{P}_1] or stem:[\mathbb{Q}_1] finite element approximation
====
The generic example of the application of <<thm:1, the previous theorem>> in dimension 2 or 3 is that of the Lagrangian finite element approximation stem:[\mathbb{P}_1] or stem:[\mathbb{Q}_1], for which, if <<laplace-varf,the problem>> is regularizing, we have
[stem]
++++
\begin{equation*}
\left\|u-u_h\right\|_{0, \Omega}+h\left\|u-u_h\right\|_{1, \Omega} \leq c h^2\|f\|_{0, \Omega} .
\end{equation*}
++++

We thus obtain a convergence to **order 1 in stem:[H^1] norm and a convergence to order 2 in stem:[L^2] norm.**
====

=== Example of homogeneous Dirichlet problem

We now consider an example to illustrate the <<thm:1,previous theorem>>.

We start by initializing the {feelpp} environment.

[[code:1]]  
[source,python]
----
import sys
import feelpp
import feelpp.toolboxes.core as tb
from feelpp.toolboxes.cfpdes import *
import pandas as pd

sys.argv = ["feelpp_cfpdes_poisson"]
e = feelpp.Environment(sys.argv,
                        opts=tb.toolboxes_options("coefficient-form-pdes", "cfpdes"),
                        config=feelpp.globalRepository("cfpdes-poisson-homogeneous-dirichlet"))
----

Then we consider the stem:[\mathbb{R}^2] domain stem:[\Omega] defined by stem:[\Omega=\left\{x \in \mathbb{R}^2; 0 \leq x_1 \leq 1, 0 \leq x_2 \leq 1\right\}].
We consider the following mesh stem:[\mathcal{T}_h] of stem:[\Omega] with stem:[h=0.1].

[[code:2]]
[source,python]
----
def generateGeometry(filename,dim=2,hsize=0.1):
    """create gmsh mesh

    Args:
        filename (str): name of the file
        dim (int): dimension of the mesh
        hsize (float): mesh size
    """
    geo="""SetFactory("OpenCASCADE");
    h={};
    dim={};
    """.format(hsize,dim)
    if dim==2 :
        geo+="""
        Rectangle(1) = {0, 0, 0, 1, 1, 0};
        Characteristic Length{ PointsOf{ Surface{1}; } } = h;
        Physical Curve("Gamma_D") = {1,2,3,4};
        Physical Surface("Omega") = {1};
        """ 
    elif dim==3 :
        geo+="""
        Box(1) = {0, 0, 0, 1, 1, 1};
        Characteristic Length{ PointsOf{ Volume{1}; } } = h;
        Physical Surface("Gamma_D") = {1,2,3,4,5,6};
        Physical Volume("Omega") = {1};
        """
    with open(filename, 'w') as f:
        # Write the string to the file
        f.write(geo)

def getMesh(filename,hsize=0.05,dim=2,verbose=False):
    """create mesh

    Args:
        filename (str): name of the file
        hsize (float): mesh size
        dim (int): dimension of the mesh
        verbose (bool): verbose mode
    """
    import os
    for ext in [".msh",".geo"]:
        f=os.path.splitext(filename)[0]+ext
        # print(f)
        if os.path.exists(f):
            os.remove(f)
    if verbose:
        print(f"generate mesh {filename} with hsize={hsize} and dimension={dim}")
    generateGeometry(filename=filename,dim=dim,hsize=hsize)
    mesh = feelpp.load(feelpp.mesh(dim=dim,realdim=dim), filename, hsize)
    return mesh

# generate 2D abd 3D meshes    
for dim in [2,3]:    
    mesh = getMesh(f"omega-{dim}d.geo",hsize=0.1,dim=dim,verbose=True)
----


Then we consider the following right hand side stem:[f] and the exact solution stem:[u(x,y) = \sin(2 \pi x) \sin(2 \pi y)] such that 
[stem]
++++
f=-\Delta u = 8 \pi^2 \sin(2 \pi x) \sin(2 \pi y)
++++
that way we can check the <<thm:1>> with the exact solution. 

The {cfpdes} toolbox allows to solve the problem <<laplace-varf,problem>> with the following code:
    
[[code:3]]
[source,python]
----
def laplacian(hsize, json, dim=2,verbose=False):
    if verbose:
        print(f"Solving the laplacian problem for hsize = {hsize}...")
    laplacian = cfpdes(dim=dim, keyword=f"cfpdes-{dim}d")
    laplacian.setMesh(getMesh(f"omega-{dim}.geo",hsize=hsize,dim=dim,verbose=verbose))
    laplacian.setModelProperties(json)
    laplacian.init(buildModelAlgebraicFactory=True)
    laplacian.printAndSaveInfo()
    laplacian.solve()
    laplacian.exportResults()
    measures = laplacian.postProcessMeasures().values()

    return measures

laplacian_json = lambda order,dim=2,name="u":  {
    "Name": "Laplacian",
    "ShortName": "Laplacian",
    "Models":
    {
        f"cfpdes-{dim}d":
        {
            "equations":"laplace"
        },
        "laplace":{
            "setup":{
                "unknown":{
                    "basis":f"Pch{order}",
                    "name":f"{name}",
                    "symbol":"u"
                },
                "coefficients":{
                    "c":"1",

                    "f":"8*pi*pi*sin(2*pi*x)*sin(2*pi*y):x:y" if dim==2 else "12*pi*pi*sin(2*pi*x)*sin(2*pi*y)*sin(2*pi*z):x:y:z"
                }
            }
        }
    },
    "Materials":
    {
        "Omega":
        {
            "markers":["Omega"]
        }
    },
    "BoundaryConditions":
    {
        "laplace":
        {
            "Dirichlet":
            {
                "g":
                {
                    "markers":["Gamma_D"],
                    "expr":"0"
                }
            }
        }
    },
    "PostProcess":
    {
        f"cfpdes-{dim}d":
        {
            "Exports":
            {
                "fields":["all"],
                "expr":{
                    "u_exact":"sin(2*pi*x)*sin(2*pi*y):x:y" if dim==2 else "sin(2*pi*x)*sin(2*pi*y)*sin(2*pi*z):x:y:z",
                    "grad_u_exact": "{2*pi*cos(2*pi*x)*sin(2*pi*y),2*pi*sin(2*pi*x)*cos(2*pi*y)}:x:y" if dim==2 else "{2*pi*cos(2*pi*x)*sin(2*pi*y)*sin(2*pi*z),2*pi*sin(2*pi*x)*cos(2*pi*y)*sin(2*pi*z),2*pi*sin(2*pi*x)*sin(2*pi*y)*cos(2*pi*z)}:x:y:z"
                }
            },
            "Measures" :
            {
              "Norm" :
              {
                  "laplace" :
                  {
                     "type":["L2-error", "H1-error"],
                     "field":f"laplace.{name}",
                     "solution":"sin(2*pi*x)*sin(2*pi*y):x:y" if dim==2 else "sin(2*pi*x)*sin(2*pi*y)*sin(2*pi*z):x:y:z",
                     "grad_solution":"{2*pi*cos(2*pi*x)*sin(2*pi*y),2*pi*sin(2*pi*x)*cos(2*pi*y)}:x:y" if dim==2 else "{2*pi*cos(2*pi*x)*sin(2*pi*y)*sin(2*pi*z),2*pi*sin(2*pi*x)*cos(2*pi*y)*sin(2*pi*z),2*pi*sin(2*pi*x)*sin(2*pi*y)*cos(2*pi*z)}:x:y:z",
                     "markers":"Omega",
                     "quad":6
                 }
              }
            }
        }
    }
}
# simulate the laplacian problem for 2D and 3D
for dim in [2,3]:
    with open(f'laplacian-{dim}d.json', 'w') as f:
        # Write the string to the file
        import json
        f.write(json.dumps(laplacian_json(dim=dim,order=1),indent=1))
        # execute the laplacian problem using P1 basis on a mesh of the unit square  of size 0.1
        laplacian(hsize=0.1,json=laplacian_json(order=1,dim=dim), dim=dim,verbose=True)
# execute the laplacian problem using P2 basis on a mesh of the unit square of size 0.1
#laplacian(hsize=0.025,json=laplacian_json(dim=2,order=2),dim=2,verbose=True)
----


[%collapsible.result]
.Results
====
----
Solving the laplacian problem for hsize = 0.1...
{'Norm_laplace_H1-error': 0.9578973774398879,
 'Norm_laplace_L2-error': 0.0256824272246114}
----
====

We can proceed with the visualisation of the field `u` using the following code using `pyvista`:

[[code:4]]
[source,python]
----
from xvfbwrapper import Xvfb # <1>
vdisplay = Xvfb()
vdisplay.start()

import pyvista as pv # <2>
import os
pv.set_jupyter_backend('panel') # <3>
def pv_get_mesh(mesh_path):
    reader = pv.get_reader(mesh_path)
    mesh = reader.read()
    return mesh
def pv_plot(mesh, field, clim=None, cmap='viridis', cpos='xy', show_scalar_bar=True, show_edges=True):
    mesh.plot(scalars=field, clim=clim, cmap=cmap, cpos=cpos, show_scalar_bar=show_scalar_bar, show_edges=show_edges)

def myplots(dim=2, field="cfpdes.laplace.u", factor=1, cmap='viridis'):
    mesh = pv_get_mesh(f"cfpdes-{dim}d.exports/Export.case") # <4>
    pv_plot(mesh, field) # <5>
    pl = pv.Plotter()
    contours = mesh[0].contour()
    pl.add_mesh(mesh[0], opacity=0.85)
    pl.add_mesh(contours, color="white", line_width=5, render_lines_as_tubes=True)
    pl.show()
    if dim == 2:
        warped = mesh[0].warp_by_scalar(field, factor=factor)
        warped.plot(cmap=cmap, show_scalar_bar=False, show_edges=True)
    else:
        slices = mesh.slice_orthogonal(x=0.2,y=0.4,z=.6)
        slices.plot()

myplots(dim=2,factor=0.5)
----
<1> The `xvfbwrapper` package is used to run the `pyvista` visualisation in a virtual display. This is necessary when running the code on a remote server.
<2> The `pyvista` package is used to visualise the mesh and the field `u`.
<3> The `set_jupyter_backend` function is used to set the backend to `panel`, use `static` instead to render an image and display it in the notebook.
<4> The `Export.case` file is generated by the `cfpdes` toolbox. It contains the mesh and the field `u`. The `pyvista` package provides a Ensight case reader to read the `Export.case` file.
<5> The `pyvista` package provides a `plot` function to visualise the mesh and the field `u` amd the edges of the mesh.

[%collapsible.result]
.Results
====
image::pyfeelpp-toolboxes/cfpdes/cfpdes.laplace.u-pv.png[width=50%]
====

In 3D, the plots are more difficult to visualise. We can use the `pyvista` package to visualise the mesh and the field `u`:

[[code:4]]
[source,python]
----
myplots(dim=3)
----

Then we can run the following code to:

- compute the solution for different mesh sizes and compute the error in stem:[L^2] and stem:[H^1] norms
- compute the convergence rates of the error in stem:[L^2] and stem:[H^1] norms
- display the errors in stem:[L^2] and stem:[H^1] norms in a table
- check that the convergence rates are close to the expected theoretical values

[[code:4]]
[source,python]
----
import pandas as pd
import numpy as np

def runLaplacianPk(df,model,verbose=False):
    """generate the Pk case

    Args:
        order (int, optional): order of the basis. Defaults to 1.
    """
    meas=dict()
    dim,order,json=model
    for h in df['h']:
        m=laplacian(hsize=h,json=json,dim=dim,verbose=verbose)
        for norm in ['L2','H1']:
            meas.setdefault(f'P{order}-Norm_laplace_{norm}-error', [])
            meas[f'P{order}-Norm_laplace_{norm}-error'].append(m.pop(f'Norm_laplace_{norm}-error'))
    df=df.assign(**meas)
    for norm in ['L2','H1']:
        df[f'P{order}-laplace_{norm}-convergence-rate']=np.log2(df[f'P{order}-Norm_laplace_{norm}-error'].shift() / df[f'P{order}-Norm_laplace_{norm}-error']) / np.log2(df['h'].shift() / df['h'])
    return df

def runConvergenceAnalysis(json,dim=2,hs=[0.1,0.05,0.025,0.0125],orders=[1,2],verbose=False):
    df=pd.DataFrame({'h':hs})
    for order in orders:
        df=runLaplacianPk(df=df,model=[dim,order,json(dim=dim,order=order)],verbose=verbose)
    print(df.to_markdown()) # <1>
    return df

df=runConvergenceAnalysis(json=laplacian_json,dim=2,verbose=True)
----
<1> The `to_markdown` function is used to display the results in a table.


[%collapsible.result]
.Results
====
----
|    |      h |   P1-Norm_laplace_L2-error |   P1-Norm_laplace_H1-error |   P1-laplace_L2-convergence-rate |   P1-laplace_H1-convergence-rate |   P2-Norm_laplace_L2-error |   P2-Norm_laplace_H1-error |   P2-laplace_L2-convergence-rate |   P2-laplace_H1-convergence-rate |
|---:|-------:|---------------------------:|---------------------------:|---------------------------------:|---------------------------------:|---------------------------:|---------------------------:|---------------------------------:|---------------------------------:|
|  0 | 0.1    |                0.0256824   |                   0.957897 |                        nan       |                       nan        |                0.00108252  |                 0.0931597  |                        nan       |                        nan       |
|  1 | 0.05   |                0.00674339  |                   0.492079 |                          1.92924 |                         0.960981 |                0.000139537 |                 0.0240171  |                          2.95567 |                          1.95564 |
|  2 | 0.025  |                0.00170431  |                   0.247621 |                          1.98429 |                         0.990757 |                1.75159e-05 |                 0.00601782 |                          2.99391 |                          1.99675 |
|  3 | 0.0125 |                0.000426066 |                   0.123856 |                          2.00004 |                         0.999468 |                2.16968e-06 |                 0.00150015 |                          3.01311 |                          2.00414 |
----
====

In 3D, we use the same code to verify the convergence rates of the error in stem:[L^2] and stem:[H^1] norms.
However we do this for different mesh sizes and only in stem:[\mathbb{P}^1] to reduce the computational cost which increases significantly with the dimension.

[[code:4]]
[source,python]
----
df3d=runConvergenceAnalysis(json=laplacian_json,dim=3,hs=[0.1,0.05,0.03],orders=[1],verbose=True)
----

Again, we observe that the proper convergence rates are obtained.

[%collapsible.result]
.Results
====
----
|    |    h |   P1-Norm_laplace_L2-error |   P1-Norm_laplace_H1-error |   P1-laplace_L2-convergence-rate |   P1-laplace_H1-convergence-rate |
|---:|-----:|---------------------------:|---------------------------:|---------------------------------:|---------------------------------:|
|  0 | 0.1  |                 0.060237   |                   1.53146  |                        nan       |                       nan        |
|  1 | 0.05 |                 0.0157572  |                   0.781105 |                          1.93464 |                         0.971323 |
|  2 | 0.03 |                 0.00531707 |                   0.452647 |                          2.12671 |                         1.06807  |
----
====

Finally we postprocess the results using plotly. 
The following code allows to 

- plot the error in stem:[L^2] and stem:[H^1] norms in plotly
- display the convergence rates in the legend of the plot
- check that the convergence rates are close to the theoretical values

[[code:5]]
[source,python]
----
import plotly.express as px
from plotly.subplots import make_subplots
import itertools

def plot_convergence(df,dim,orders=[1,2]):
    fig=px.line(df, x="h", y=[f'P{order}-Norm_laplace_{norm}-error' for order,norm in list(itertools.product(orders,['L2','H1']))])
    fig.update_xaxes(title_text="h",type="log")
    fig.update_yaxes(title_text="Error",type="log")
    for order,norm in list(itertools.product(orders,['L2','H1'])):
        fig.update_traces(name=f'P{order} - {norm} error - {df[f"P{order}-laplace_{norm}-convergence-rate"].iloc[-1]:.2f}', selector=dict(name=f'P{order}-Norm_laplace_{norm}-error'))
    fig.update_layout(
            title=f"Convergence rate for the {dim}D Laplacian problem",
            autosize=False,
            width=900,
            height=900,
        )
    fig.show()
plot_convergence(df,dim=2)
plot_convergence(df3d,dim=3,orders=[1])
----

[%collapsible.result]
.Results
====
image:pyfeelpp-toolboxes/cfpdes/cfpdes.poisson-1.png[width=100%]
====

== Other boundary conditions

The previous example shows how to solve a Poisson problem with Dirichlet boundary conditions.

=== Inhomogeneous Dirichlet boundary conditions

Given a function stem:[f \in L^2(\Omega)] and a function stem:[g \in \mathcal{C}^{0,1}(\partial \Omega)] ( stem:[g] is lipschitzian on stem:[\partial \Omega]), we look for a function stem:[u: \Omega \rightarrow \mathbb{R}] such that
[stem]
++++
\begin{equation*}
\begin{aligned}
& -\Delta u=f \text { in } \Omega \text {, } \\
& u=g \quad \text { on } \partial \Omega . \\
&
\end{aligned}
\end{equation*}
++++

[NOTE]
====
We can take stem:[g] in the fractional Sobolev space stem:[H^{\frac{1}{2}}(\partial \Omega)] defined as 
[stem]
++++
H^{\frac{1}{2}}(\partial \Omega)=\left\{v \in L^2(\partial \Omega) ; \frac{v(x)-v(y)}{\|x-y\|^{\frac{d+1}{2}}} \in L^2(\partial \Omega \times \partial \Omega)\right\}.
++++
====

The hypothesis stem:[g \in \mathcal{C}^{0,1}(\partial \Omega)] allows us to assert that there exists a lifting stem:[u_g] of stem:[g] in stem:[H^1(\Omega)], that is to say that there exists a function stem:[u_g] in stem:[H^1(\Omega)] such that stem:[\left.u_g\right|_{\partial \Omega}=g]. 

Under these conditions, we perform the change of unknown stem:[u_0=u-u_g] and consider the following weak formulation:

[[laplace-dir]]
[stem]
++++
\begin{equation*}
\left\{\begin{array}{l}
\text { Find } u_0 \in H_0^1(\Omega) \text { such that } \\
a\left(u_0, w\right)=f(w)-a\left(u_g, w\right), \quad \forall w \in H_0^1(\Omega) .
\end{array}\right.
\end{equation*}
++++

By the Lax-Milgram lemma, this problem is well posed.
We are interested in a conformal approximation of <<laplace-dir,the problem>> by Lagrange finite elements. 
We use the discrete framework described previously.
We suppose that the data stem:[g] is regular enough to admit a lifting stem:[u_g] in stem:[\mathcal{C}^0(\bar{\Omega}) \cap H^1(\Omega)]. 
We denote stem:[\mathcal{I}_h^{\mathrm{Lag}}] the interpolation operator associated with the mesh stem:[\mathcal{T}_h] and the finite Lagrangian element of reference stem:[\widehat{K}, \widehat{P}, \widehat{\Sigma}}].
Recall that stem:[P_{\mathrm{c}, h}^k] denotes the stem:[H^1]-conformal space based on this finite element and that stem:[V_h] is the stem:[H_0^1]-conformal approximation space defined in (5.9). 

Let stem:[N=\operatorname{dim} P_{\mathrm{c}, h}^k] be given. 
We denote by stem:[\left\{\varphi_1, \ldots, \varphi_N\right\}] the nodal basis of stem:[P_{\mathrm{c}, h}^k] and by stem:[\left\{a_1, \ldots, a_N\right\}] the associated nodes. 
By definition, for stem:[u \in \mathcal{C}^0(\bar{\Omega})], we have
[stem]
++++
\begin{equation*}
\mathcal{I}_h^{\mathrm{Lag}} u=\sum_{i=1}^N u\left(a_i\right) \varphi_i
\end{equation*}
++++

and we also introduce the surface Lagrange interpolation
[stem]
++++
\begin{equation*}
\mathcal{I}_h^{\mathrm{Lag} \partial}\left(\left.u\right|_{\partial \Omega}\right)=\left.\sum_{a_i \in \partial \Omega} u\left(a_i\right) \varphi_i\right|_{\partial \Omega}
\end{equation*}
++++

We consider the approximated problem
[stem]
++++
\begin{equation*}
\left\{\begin{array}{l}
\text { Find } u_{0 h} \in V_h \text { such that } \\
a\left(u_{0 h}, w_h\right)=f\left(w_h\right)-a\left(\mathcal{I}_h^{\mathrm{Lag}} u_g, w_h\right), \quad \forall w_h \in V_n,
\end{array}\right.
\end{equation*}
++++
which is clearly well posed. 
We pose stem:[u_h=u_{0 h}+\mathcal{I}_h^{\mathrm{Lag}} u_g] so that stem:[\left.u_h\right|_{partial \Omega}] coincides with the Lagrange interpolated surface of stem:[g]. 

stem:[u_h] is the solution of the problem
[stem]
++++
\begin{equation*}
\left\{\begin{array}{l}
\text { Find } u_h \in P_{\mathrm{c}, h}^k \text { such that } \\
a\left(u_h, w_h\right)=f\left(w_h\right), \quad \forall w_h \in V_h, \
\left.u_h\right|_{\partial \Omega}=\mathcal{I}_h^{\mathrm{Lag}\, \partial} g .
\end{array}\right.
\end{equation*}
++++

IMPORTANT: For any surface node stem:[x_i \in \partial \Omega], then stem:[u_h\left(x_i\right)=g\left(x_i\right)], but in general stem:[\left.u_h\right|_{\partial \Omega} \neq g].

[[thm:1:3]]
.Convergence theorem for the inhomogeneous Dirichlet problem
****
With the above assumptions, assume that the unique solution stem:[u] of <<laplace-dir>> is in stem:[H^{k+1}(\Omega) \cap H_0^1(\Omega)]. 
Then there exists a constant stem:[c] such that for all stem:[h],
[stem]
++++
\begin{equation*}
\left\|u-u_h\right\|_{1, \Omega} \leq c h^k|u|_{k+1, \Omega} .
\end{equation*}
++++
Moreover, if <<laplace-dir,the problem>> is regularizing, there exists a constant stem:[\mathrm{c}] such that for all stem:[h],
[stem]
++++
\begin{equation*}
\left\|u-u_h\right\|_{0, \Omega} \leq c h^{k+1}|u|_{k+1, \Omega}
\end{equation*}
++++
****

==== Example 

Then we consider the stem:[\mathbb{R}^2] domain stem:[\Omega] defined by stem:[\Omega=\left\{x \in \mathbb{R}^2; 0 \leq x_1 \leq 1, 0 \leq x_2 \leq 1\right\}].
We consider the following mesh stem:[\mathcal{T}_h] of stem:[\Omega] with stem:[h=0.1].

We shall replace the exact solution by stem:[u(x,y)=\sin(2\pi x) \cos(2\pi y)] which yields 
[stem]
++++
f=\Delta u=4\pi^2 \sin(2\pi x) \cos(2\pi y).
++++
the boundary condition stem:[g=0] is replace by stem:[h=u] on stem:[\partial \Omega].

[source, python]
----
# get the laplacian json model
def laplacian_g_json(dim,order=1):
    j=laplacian_json(dim=dim,order=order)
    if dim == 2:
        j['Models']['laplace']['setup']['coefficients']['f']=f'8*(pi^2)*sin(2*pi*x)*cos(2*pi*y):x:y'
        j['BoundaryConditions']['laplace']['Dirichlet']['g']={
                                                                "markers":["Gamma_D"],
                                                                "expr":"sin(2*pi*x)*cos(2*pi*y):x:y"
                                                             }
        j['PostProcess'][f'cfpdes-2d']['Measures']['Norm']['laplace']['solution']='sin(2*pi*x)*cos(2*pi*y):x:y'
        j['PostProcess'][f'cfpdes-2d']['Measures']['Norm']['laplace']['grad_solution']='{2*pi*cos(2*pi*x)*cos(2*pi*y),-2*pi*sin(2*pi*x)*sin(2*pi*y)}:x:y'
    else:
        j['Models']['laplace']['setup']['coefficients']['f']='12*(pi^2)*sin(2*pi*x)*cos(2*pi*y)*cos(2*pi*z):x:y:z'
        j['BoundaryConditions']['laplace']['Dirichlet']['g']={
                                                                "markers":["Gamma_D"],
                                                                "expr":"sin(2*pi*x)*cos(2*pi*y)*cos(2*pi*z):x:y:z"
                                                             }
        j['PostProcess'][f'cfpdes-3d']['Measures']['Norm']['laplace']['solution']='sin(2*pi*x)*cos(2*pi*y)*cos(2*pi*z):x:y:z'
        j['PostProcess'][f'cfpdes-3d']['Measures']['Norm']['laplace']['grad_solution']='{2*pi*cos(2*pi*x)*cos(2*pi*y)*cos(2*pi*z),-2*pi*sin(2*pi*x)*sin(2*pi*y)*cos(2*pi*z),-2*pi*sin(2*pi*x)*cos(2*pi*y)*sin(2*pi*z)}:x:y:z'
    return j

# in 2D
laplacian(hsize=0.1,json=laplacian_g_json(dim=2,order=1),dim=2)

# in 3D
laplacian(hsize=0.1,json=laplacian_g_json(dim=3,order=1),dim=3)
----

We can then plot the 2D results

[source,python]
----
# plot the 2D results
myplots(dim=2)
----

and plot the 3D results

[source,python]
----
# plot the 3D results
myplots(dim=3)
----

We now run the convergence analysis and verify the convergence rate expected from <<thm:1>> in 2D.

[source,python]
----
# run the 2D convergence analysis
df=runConvergenceAnalysis(json=laplacian_g_json,dim=2,verbose=True)
----

We now run the convergence analysis and verify the convergence rate expected from <<thm:1>> in 2D.

[source,python]
----
# run the 2D convergence analysis
df3d=runConvergenceAnalysis(json=laplacian_g_json,dim=3,hs=[0.1,0.05,0.03], orders=[1], verbose=True)
----


=== Neumann boundary conditions

Given a strictly positive real stem:[\lambda], a function stem:[f \in L^2(\Omega)] and a function stem:[g \in L^2(\partial \Omega)], we look for a function stem:[u: \Omega \rightarrow \mathbb{R}] such that

[[laplace-N]]
[stem]
++++
\begin{equation*}
\begin{aligned}
& -\Delta u+\lambda u=f \quad \text { in } \Omega \text {, } \\
& \partial_n u=g \quad \operatorname{on} \partial \Omega \text {, } \\
&
\end{aligned}
\end{equation*}
++++
where stem:[\partial_n u] denotes the normal derivative of stem:[u] on the boundar. 

NOTE: By noting stem:[n=\left(n_1, \ldots, n_d\right)^T] the Cartesian coordinates of the exterior normal at a point of the boundary, we have by definition stem:[\partial_n u=n \cdot \nabla u=\sum_{i=1}^d n_i \partial_i u].

The weak formulation of <<laplace-N,the Neumann problem>> reads
[[laplace-N-vf]]
[stem]
++++
\begin{equation*}
\left\{\begin{array}{l}
\text { Find } u \in H^1(\Omega) \text { such that } \\
a_{\mathrm{N}}(u, w)=f_{\mathrm{N}}(w), \quad \forall w \in H^1(\Omega),
\end{array}\right.
\end{equation*}
++++
where
[stem]
++++
\begin{equation*}
a_{\mathrm{N}}(v, w)=\int_{\Omega} \nabla v \cdot \nabla w+\int_{\Omega} \lambda v w
\end{equation*}
++++
and
[[laplace-N-vf-fN]]
[stem]
++++
\begin{equation*}
f_{\mathrm{N}}(w)=\int_{\Omega} f w+\int_{\partial \Omega} g w
\end{equation*}
++++
The well-posedness of <<laplace-N-vf, the weak formulation>> results from the coercivity of the bilinear form stem:[a_{\mathrm{N}} \operatorname{on} H^1(\Omega)].
The <<laplace-N-vf,problem>> can be approximated by Lagrange finite elements. 
We take the discrete framework described for the <<_conforming_approximation>>. 
We consider the following approximated problem:
[[laplace-N-approx]]
[stem]
++++
\begin{equation*}
\left\{\begin{array}{l}
\text { Find } u_h \in P_{\mathrm{c}, h}^k \text { such that } \\
a_{\mathrm{N}}\left(u_h, w_h\right)=f_{\mathrm{N}}\left(w_h\right), \quad \forall w_h \in P_{\mathrm{c}, h}^k,
\end{array}\right.
\end{equation*}
++++
which is clearly **well-posed**. 

IMPORTANT: An important difference between the Neumann boundary condition and the Dirichlet boundary condition is that the former is not imposed explicitly in the space where the solution is sought but results from the fact that the test functions in <<laplace-N-vf, the variational formulation>> can take zero values at the edge. This difference is reflected in the finite element approximation by the fact that the solution stem:[u_h] of <<laplace-N-approx,the discrete Neumann problem>> satisfies the Neumann boundary condition in an approximate way and not in an exact way. 

Finally, the convergence analysis of the  <<laplace-N-approx,approximatio problem>> leads, under the assumptions of <<thm:1,Theorem>>, to the same estimates as for the homogeneous Dirichlet problem.

We can also consider, at the cost of some technical difficulties, the Neumann problem with stem:[\lambda=0]. 
We look for a function stem:[u: \Omega \rightarrow \mathbb{R}] such that
[[laplace-N-0]]
[stem]
++++
\begin{equation*}
\begin{array}{rr}
-\Delta u=f & \text { in } \Omega, \\
\partial_n u=g & \text { on } \partial \Omega .
\end{array}
\end{equation*}
++++

[IMPORTANT]
.Necessary condition for the existence of a solution for the Neumann problem with stem:[\lambda=0]
====
We observe that a necessary condition for the existence of a solution is that the data stem:[f] and stem:[g] satisfy the compatibility condition
[[laplace-N-0-cond]]
[stem]
++++
\begin{equation*}
\int_{\Omega} f+\int_{\partial \Omega} g=0
\end{equation*}
++++
since stem:[\int_{\Omega} f+\int_{\partial \Omega} g=-\int_{\Omega} \Delta u+\int_{\partial \Omega} \partial_n u=0] according to the divergence theorem. 
====

[NOTE]
.Divergence theorem
====
The divergence theorem expresses the fact that for any stem:[\phi] vector field that is sufficiently regular,
[stem]
++++
\begin{equation*}
\int_{\Omega} \nabla \cdot \phi=\int_{\partial \Omega} \phi \cdot n
\end{equation*}
++++
In particular, taking stem:[\phi=\nabla u] where stem:[u] is a sufficiently regular function, we get stem:[\int_{\Omega} \Delta u=\int_{\partial \Omega} \partial_n u].
====

A solution of the <<laplace-N-0,problem>> with the <<laplace-N-cond,condition>>  is only determined to within one additive constant. 
We should then look for the solution in the functional space
[stem]
++++
\begin{equation*}
H_*^1(\Omega)=\left\{v \in H^1(\Omega); \int_{\Omega} v=0\right\} .
\end{equation*}
++++
The weak formulation is the following:
[[laplace-N-0-vf]]
[stem]
++++
\begin{equation*}
\left\{\begin{array}{l}
\text { Find } u \in H_*^1(\Omega) \text { such that } \\
a(u, w)=f_{\mathrm{N}}(w), \quad \forall w \in H_*^1(\Omega),
\end{array}\right.
\end{equation*}
++++
with the bilinear form $a$ such that stem:[a(v, w)=\int_{\Omega} \nabla v \cdot \nabla w].

The well-posedness of <<laplace-N-0-vf,problem>> results from the coercivity of the bilinear form a on stem:[H_*^1(\Omega)], this last property being itself a consequence of the inequality below.

[[lem:2]]
.Lemma: Poincaré-Wirtinger inequality. 
****
Let stem:[\Omega] be a bounded open of stem:[\mathbb{R}^d]. 
There exists a constant stem:[\ell_{\Omega}^{\prime \prime}] such that
[stem]
++++
\begin{equation*}
\forall v \in H_*^1(\Omega), \quad\|v\|_{0, \Omega} \leq \ell_{\Omega}^{\prime \prime} \|\nabla v\|_{0, \Omega}
\end{equation*}
++++
****

The <<laplace-N-0-vf,problem>>  can be approximated by Lagrangian finite elements, which leads to the following approximated problem:
[[laplace-N-0-approx]]
[stem]
++++
\begin{equation*}
\left\{\begin{array}{l}
\text { Find } u_h \in P_{\mathrm{c}, h}^k \text { such that } \\
a\left(u_h, w_h\right)=f_{\mathrm{N}}\left(w_h\right), \quad \forall w_h \in P_{\mathrm{c}, h}^k .
\end{array}\right.
\end{equation*}
++++

NOTE: the approximation space stem:[P_{\mathrm{c}, h}^k] is not conformal in stem:[H_*^1(\Omega)] and that the linear system associated to the <<discrete problem,laplace-N-0-vf-approx>> is singular. 

By noting this linear system in the form
[[laplace-N-0-approx-sys]]
[stem]
++++
\begin{equation*}
\mathcal{A}^* U=F^*
\end{equation*}
++++
and introducing the vector stem:[Z=(1, \ldots, 1)^T \in \mathbb{R}^N] where stem:[N=\operatorname{dim} P_{\mathrm{c}, h}^k], we find that stem:[\operatorname{Ker}\left(\mathcal{A}^*\right)=\operatorname{span}(Z), \operatorname{Im}\left(\mathcal{A}^*\right)=Z^{\perp}] and stem:[F^* \in Z^{\perp}]. 
Therefore, the <<laplace-N-0-approx-sys,linear system>>  has infinitely many solutions. 
One of them can be approximated using an iterative method, for example the conjugate gradient method. 
We denote by stem:[U^{\circ}] the approximation provided by the iterative method. 
The solution of the <<laplace-N-0-approx-sys,linear system>> whose components have zero mean is obtained by posing
[[laplace-N-0-approx-sol]]
[stem]
++++
\begin{equation*}
U=U^{\circ}-\left(\frac{\left(U^{\circ}, Z\right)_{\mathbb{R}^N}}{(Z, Z)_{\mathbb{R}^N}}\right) Z
\end{equation*}
++++
where stem:[(\cdot, \cdot)_{\mathbb{R}^N}] denotes the Euclidean scalar product on stem:[\mathbb{R}^N].  \
The <<laplace-N-0-approx-sol,postprocessing of the solution>> removes the mean value of the solution stem:[U^{\circ}] and is necessary to obtain the zero mean solution of <<laplace-N-0-approx,problem>>.

An alternative way to obtain the solution of <<laplace-N-0-approx-sys,linear system>> is to use the method of Lagrange multipliers to impose the condition stem:[\int_{\Omega} u=0].

==== Example

Consider the <<laplace-N-0,problem>> with stem:[\Omega=\mathbb{R}^2] and the exact solution stem:[u(x, y)=\sin(2*\pi*x) \sin(2*\pi*y)] in 2D and stem:[u(x, y, z)=\sin(2*\pi*x) \sin(2*\pi*y) \sin(2*\pi*z)] in 3D.

The right hand side stem:[f] and the boundary condition stem:[g_{\mathrm{N}}] are computed using the exact solution stem:[u] in stem:[\mathbb{R}^d, d=2,3].
We have
[stem]
++++
\begin{equation*}
\begin{aligned}
f_{\mathrm{N}}(x, y)&=- \Delta u(x,y) = 4  d  \pi^2 \sin(2 \pi x) \sin(2 \pi y)\\
g_{\mathrm{N}}(x, y)&=\partial_n u(x,y) = 0
\end{aligned}
\end{equation*}
++++

NOTE: we can verify the condition <<laplace-N-0-cond>> is indeed satisfied.

The code below computes the solution of the <<laplace-N-0,problem>> using the finite element method in 2D.
[[code:laplace-N-0]]
[source,python]
----
# get the laplacian json model
def laplacian_gN_json(dim,order=1):
    j=laplacian_json(dim=dim,order=order)
    if dim == 2:
        j['Models']['laplace']['setup']['coefficients']['f']=f'8*(pi^2)*sin(2*pi*x)*sin(2*pi*y)+sin(2*pi*x)*sin(2*pi*y):x:y'
        j['Models']['laplace']['setup']['coefficients']['a']='1' # set \lambda=1
        j['BoundaryConditions']['laplace'].pop('Dirichlet')
        j['BoundaryConditions']['laplace']['Neumann']= { "gN": {
                                                                "markers":["Gamma_D"],
                                                                "expr":"2*pi*cos(2*pi*x)*sin(2*pi*y)*nx+2*pi*sin(2*pi*x)*cos(2*pi*y)*ny:x:y:nx:ny"
                                                               }
                                                        }
        j['PostProcess'][f'cfpdes-2d']['Measures']['Norm']['laplace']['solution']='sin(2*pi*x)*sin(2*pi*y):x:y'
        j['PostProcess'][f'cfpdes-2d']['Measures']['Norm']['laplace']['grad_solution']='{2*pi*cos(2*pi*x)*sin(2*pi*y),2*pi*sin(2*pi*x)*cos(2*pi*y)}:x:y'
    return j

# in 2D
laplacian(hsize=0.1,json=laplacian_gN_json(dim=2,order=1),dim=2)
----


We now run the convergence analysis and verify the convergence rate expected from <<thm:1>> in 2D.

[source,python]
----
# run the 2D convergence analysis
df=runConvergenceAnalysis(json=laplacian_gN_json,dim=2,verbose=True)
----


=== Robin Boundary Conditions

Given a function stem:[f \in L^2(\Omega)] and a function stem:[g \in L^2(\partial \Omega)], we look for a function stem:[u: \Omega \rightarrow \mathbb{R}] such that
[[laplace-R-strong]]
[stem]
++++
\begin{equation*}
\begin{aligned}
& -\Delta u=f \quad \text { in } \Omega \text {, } \\
& \gamma_R u+\partial_n u=g_R \quad \text { on } \partial \Omega, \
&
\end{aligned}
\end{equation*}
++++
where stem:[\gamma_R>0] is a real parameter. 

NOTE: More generally, consider a function stem:[\gamma_R \in L^{\infty}(\partial \Omega)] such that stem:[\gamma_R(x) \geq \gamma_0>0] for almost all stem:[x \in \partial \Omega].

The weak formulation of the <<laplace-R-strong,problem>> reads
[[laplace-R-weak]]
[stem]
++++
\begin{equation*}
\left\{\begin{array}{l}
\text { Find } u \in H^1(\Omega) \text { such that } \\
a_{\mathrm{R}}(u, w)=f_{\mathrm{N}}(w), \quad \forall w \in H^1(\Omega),
\end{array}\right.
\end{equation*}
++++
where the linear form stem:[f_{\mathrm{N}}] is defined <<laplace-N-vf-fN,here>> and the bilinear form stem:[a_{\mathrm{R}}] is such that
[stem]
++++
\begin{equation*}
a_{\mathrm{R}}(v, w)=\int_{\Omega} \nabla v \cdot \nabla w+\int_{\partial \Omega} \gamma v w
\end{equation*}
++++
The well-posedness of <<laplace-R-weak,weak problem>> results from the coercivity of stem:[a_{mathrm{R}}[] on stem:[H^1(\Omega)], this last property being itself a consequence of the fact that there exists a constant stem:[\rho_{\Omega}] such that
[stem]
++++
\begin{equation*}
\forall v \in H^1(\Omega), \quad\|v\|_{0, \Omega} \leq \rho_{\Omega} \left(\|nabla v|_{0, \Omega}+\|v\|_{0, \partial \Omega}\right) .
\end{equation*}
++++
Starting from the initial discrete framework, we are interested in an approximation  by Lagrange finite elements. 
We consider the following approximated problem:
[[laplace-R-vf-approx]]
[stem]
++++
\begin{equation*}
\left\{\begin{array}{l}
\text { Find } u_h \in P_{mathrm{c}, h}^k \text { such that } \\
a_{\mathrm{R}}\left(u_h, w_h\right)=f_{\mathrm{N}}\left(w_h\right), \quad \forall w_h \in P_{\mathrm{c}, h}^k,
\end{array}\right.
\end{equation*}
++++
which is clearly well-posed. 

NOTE: As with the Neumann boundary condition, the Robin boundary condition results from the fact that the test functions can take non-zero values at the edge; the condition is not exactly satisfied by the discrete solution stem:[u_h] but only in an approximate way. 

Finally, the convergence analysis for the stem:[u_h]  leads, under the assumptions of <<thm:1,the theorem>, to the same estimates as for the homogeneous Dirichlet problem.

==== Example

We consider the following problem in the unit square stem:[\Omega=[0,1\]^d, d=2] with  exact solution stem:[u(x,y)=\sin(2\pi x)\, \sin(2\pi y)]. We consider stem:[\gamma_R=1]
We then compute stem:[f] and stem:[g_R] such that stem:[u] is the solution of the problem <<laplace-R-strong,above>>.

We have 
[stem]
++++
\begin{equation*}
\begin{aligned}
f=-\Delta u &=2 d \pi^2 sin(2\pi x)sin(2\pi y), \\
\nabla u = { 2\pi cos(2\pi x)sin(2\pi y), 2\pi sin(2\pi x)sin(2\pi y) } \\
g_R &= +\gamma_R u+\nabla u \cdot n = \gamma_R sin(2\pi x)sin(2\pi y)+2\pi \cos(2\pi x)\sin(2\pi y) n_x +2\pi \sin(2\pi x) \cos(2\pi y) n_y.
\end{aligned}
\end{equation*}
++++
where stem:[n=(n_x,n_y)] is the outward unit normal to the boundary stem:[\partial \Omega].

The json specifications now read as follows:
[source,python]
----
# get the laplacian json model
def laplacian_gR_json(dim,order=1):
    j=laplacian_json(dim=dim,order=order)
    if dim == 2:
        j['Parameters'] = { 'gammaR': 1.0 }
        j['BoundaryConditions']['laplace'].pop('Dirichlet')
        j['BoundaryConditions']['laplace']['Robin']= { "gR": {
                                                                "markers":["Gamma_D"],
                                                                "expr1":"gammaR:gammaR:x:y",
                                                                "expr2":"gammaR*sin(2*pi*x)*sin(2*pi*y)+(2*pi*cos(2*pi*x)*sin(2*pi*y)*nx+2*pi*sin(2*pi*x)*cos(2*pi*y)*ny):gammaR:x:y:nx:ny"
                                                             }
                                                        }
    return j
        
# in 2D
laplacian(hsize=0.1,json=laplacian_gR_json(dim=2,order=1),dim=2)
----

We can now verify the convergence properties

[source,python]
----
# run the 2D convergence analysis
df=runConvergenceAnalysis(json=laplacian_gR_json,dim=2,verbose=True)
----

=== Advection-Diffusion-Reaction Equation

Consider a differential operator of the form
[[laplace-ADR-op]]]
[stem]
++++
\begin{equation*}
\mathcal{L} u=-\nabla \cdot(\sigma \cdot \nabla u)+\beta \cdot \nabla u+\mu u,
\end{equation*}
++++
where $\sigma, \beta$ and $\mu$ are functions defined on $\Omega$ and with values in $\mathbb{R}^{d, d}, \mathbb{R}^d$ and $\mathbb{R}$ respectively. 
The <<laplace-ADR-op,operator>>  is used, for example, in the modeling of advection-diffusion-reaction problems; the first term of the right-hand side is the diffusive term, the second the advective term and the third the reactive term. 

NOTE: The advective term is sometimes called the "convective" term and the equation is then called the convection-diffusion-reaction equation.


NOTE: The stem:[\mathcal{L}] operator is used in many domais such as fluid mechanics, heat transfer, finance, chemistry, etc.

In the following, we assume that stem:[\sigma \in\left[L^{\infty}(\Omega)\right\]^{d, d}, \beta \in\left[L^{\infty}(\Omega)\right\]^d, \nabla \cdot \beta \in L^{\infty}(\Omega)] and stem:[\mu \in L^{\infty}(\Omega)]. 
Moreover, we assume that the operator stem:[\mathcal{L}] is elliptic in the following sense.

.Definition: Elliptic operator. 
****
The <<laplace-ADR-op,operator stem:[\mathcal{L}]>> is said to be **elliptic** if there exists a constant stem:[\sigma_0>0] such that, almost everywhere in stem:[\Omega],
[stem]
++++
\begin{equation*}
\forall \xi \in \mathbb{R}^d, \quad \sum_{i, j=1}^d \sigma_{i j} \xi_i \xi_j \geq \sigma_0\left(\sum_{i=1}^d \xi_i^2\right) .
\end{equation*}
++++
NOTE: The Laplacian falls into the category of elliptic operators since it is obtained from stem:[\mathcal{L}] by taking stem:[\beta=0, \mu=0] and stem:[\sigma=\mathcal{I}_d], the identity matrix in stem:[\mathbb{R}^{d, d}].
****

Given a function stem:[f \in L^2(\Omega)], we look for a function stem:[u: \Omega \rightarrow \mathbb{R}] such that
[[laplace-ADR-strong]]
[stem]
++++
\begin{equation*}
\begin{aligned}
\mathcal{L} u & =f & & \text { in } \Omega, \
u & =0 & & \text { on } \partial \Omega .
\end{aligned}
\end{equation*}
++++
The weak formulation of the <<laplace-ADR-strong,strong formulation>> is the following:
[[laplace-ADR-weak]]
[stem]
++++
\begin{equation*}
\left\{\begin{array}{l}
\text { Find } u \in H_0^1(\Omega) \text { such that } \\
a_{\sigma \beta \mu}(u, w)=f(w), \quad \forall w \in H_0^1(\Omega),
\end{array}\right.
\end{equation*}
++++
with the bilinear form stem:[a_{\sigma \beta \mu}] such that for all stem:[(v, w) \in H_0^1(\Omega) \times H_0^1(\Omega)],
[stem]
++++
\begin{equation*}
a_{\sigma \beta \mu}(v, w)=\int_{\Omega} \nabla w \cdot \sigma \cdot \nabla v+w(\beta \cdot \nabla v)+\mu w v
\end{equation*}
++++
We pose stem:[p=\inf {\operatorname{ess}}{ }_{x \in \Omega}\left(\mu-\frac{1}{2} \nabla \cdot \beta\right)] and we recall that stem:[\ell_{\Omega}] is the constant intervening in the Poincaré inequality above. 

NOTE: For a function stem:[f \in L^{\infty}(\Omega), \inf \operatorname{ess}_{x \in \Omega} f(x)=\sup \left\{ M \in \mathbb{R}_{+}; f(x) \geq M \text{ almost\ everywhere\ in\ } \Omega\right\}].

Then, we show that under the condition
[[laplace-ADR-condition]]
[stem]
++++
\begin{equation*}
\sigma_0+\min \left(0, \ell_{\Omega} p\right)>0
\end{equation*}
++++
the bilinear form stem:[a_{\sigma \beta \mu}] is coercive on stem:[H_0^1(\Omega)], so that, thanks to the Lax-Milgram lemma, the <<laplace-ADR-weak,problem>>  is well posed. 
The <<laplace-ADR-condition,condition>>  being a minimization of stem:[\sigma_0], we retain that the coercivity is guaranteed provided that stem:[\sigma_0] is sufficiently large, i.e. in the *dominant diffusion regime*.

The conformal approximation  by Lagrangian finite elements uses the discrete framework introduced for the Laplacian. 
Finally, one can consider instead of non-homogeneous Dirichlet, Neumann or Robin boundary conditions. 

IMPORTANT: Convergence results are obtained in the same way as for the Laplacian, with the same assumptions on the mesh and the finite element space in the case of diffusion dominated problems, we shall see in xref:cfpdes.adr.adoc[] that the mesh and finite element space must be adapted to the problem in the case of advection dominated problems.

==== Example
we consider the same domain and exact solution as before and we set stem:[\beta=(1,1)] and stem:[\mu=1].

The json specifications now read as follows:
[source,python]
----
# get the laplacian json model
def adr_json(dim,order=1,c=1):
    j=laplacian_json(dim=dim,order=order,name="u")
    if dim == 2:
        j['Models']['laplace']['setup']['coefficients']['f']='physics_laplace_laplace_c*8*(pi^2)*sin(2*pi*x)*sin(2*pi*y)+physics_laplace_laplace_beta_0*2*pi*cos(2*pi*x)*sin(2*pi*y)+physics_laplace_laplace_beta_1*2*pi*sin(2*pi*x)*cos(2*pi*y)+physics_laplace_laplace_a*sin(2*pi*x)*sin(2*pi*y):x:y:physics_laplace_laplace_beta_0:physics_laplace_laplace_beta_1:physics_laplace_laplace_c:physics_laplace_laplace_a'
        j['Models']['laplace']['setup']['coefficients']['beta']='{1,1}'
        j['Models']['laplace']['setup']['coefficients']['a']='1'
        j['Models']['laplace']['setup']['coefficients']['c']=c
    return j
print(adr_json(dim=2,order=1,c=1e-7))
# in 2D
laplacian(hsize=0.1,json=adr_json(dim=2,order=1,c=1),dim=2)
----

[%collapsible.result]
.Results
====
----
{'Norm_laplace_H1-error': 1.1895228288020558,
 'Norm_laplace_L2-error': 0.021235807952695886}
----
====

We can plot the solution:

[source,python]
----
myplots(dim=2,field="cfpdes.laplace.u")
----

and obtain the convergence rates as follows:

[source,python]
----
# run the 2D convergence analysis with c=1 
df=runConvergenceAnalysis(json=lambda dim,order: adr_json(dim=dim,order=order,c=1),dim=2,verbose=True)
----

[appendix]
== References

- [1] docs.feelpp.org
